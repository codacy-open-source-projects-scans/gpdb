DROP TABLE IF EXISTS reindex_crtab_part_ao_btree;
DROP TABLE

CREATE TABLE reindex_crtab_part_ao_btree ( id INTEGER, owner VARCHAR, description VARCHAR, property BOX, poli POLYGON, target CIRCLE, v VARCHAR, t TEXT, f FLOAT, p POINT, c CIRCLE, filler VARCHAR DEFAULT 'Big data is difficult to work with using most relational database management systems and desktop statistics and visualization packages, requiring instead massively parallel software running on tens, hundreds, or even thousands of servers.What is considered big data varies depending on the capabilities of the organization managing the set, and on the capabilities of the applications.This is here just to take up space so that we use more pages of data and sequential scans take a lot more time. ') with (appendonly=true) DISTRIBUTED BY (id) PARTITION BY RANGE (id) ( PARTITION p_one START('1') INCLUSIVE END ('10') EXCLUSIVE, DEFAULT PARTITION de_fault );
CREATE TABLE
insert into reindex_crtab_part_ao_btree (id, owner, description, property, poli, target) select i, 'user' || i, 'Testing GiST Index', '((3, 1300), (33, 1330))','( (22,660), (57, 650), (68, 660) )', '( (76, 76), 76)' from generate_series(1,1000) i ;
INSERT 0 1000
insert into reindex_crtab_part_ao_btree (id, owner, description, property, poli, target) select i, 'user' || i, 'Testing GiST Index', '((3, 1300), (33, 1330))','( (22,660), (57, 650), (68, 660) )', '( (76, 76), 76)' from generate_series(1,1000) i ;
INSERT 0 1000
create index on reindex_crtab_part_ao_btree(id);
CREATE INDEX
-- @product_version gpdb: [4.3.4.0 -],4.3.4.0O2
-- @Description Ensures that a reindex table during reindex index operations is ok
--

DELETE FROM reindex_crtab_part_ao_btree  WHERE id < 128;
DELETE 254
3: create temp table old_relfilenodes as (select gp_segment_id as dbid, relfilenode, oid, relname from gp_dist_random('pg_class') where relname like 'reindex_crtab_part_ao_btree%_idx' union all select gp_segment_id as dbid, relfilenode, oid, relname from pg_class where relname like 'reindex_crtab_part_ao_btree%_idx');
SELECT 12
1: BEGIN;
BEGIN
1: LOCK reindex_crtab_part_ao_btree IN ACCESS EXCLUSIVE MODE;
LOCK TABLE
2&: REINDEX TABLE  reindex_crtab_part_ao_btree;  <waiting ...>
3:BEGIN;
BEGIN
3&: reindex index reindex_crtab_part_ao_btree_1_prt_de_fault_id_idx;  <waiting ...>
1: COMMIT;
COMMIT
3<:  <... completed>
REINDEX
-- Session 2 has not committed yet.  Session 3 should see effects of
-- its own reindex command above in pg_class.  The following query
-- validates that reindex command in session 3 indeed generates new
-- relfilenode for the index.
3: insert into old_relfilenodes (select gp_segment_id as dbid, relfilenode, oid, relname from gp_dist_random('pg_class') where relname like 'reindex_crtab_part_ao_btree%_idx' union all select gp_segment_id as dbid, relfilenode, oid, relname from pg_class where relname like 'reindex_crtab_part_ao_btree%_idx');
INSERT 0 12
-- Expect two distinct relfilenodes for one segment in old_relfilenodes table.
3: select distinct count(distinct relfilenode), relname from old_relfilenodes group by dbid, relname;
 count | relname                                           
-------+---------------------------------------------------
 1     | reindex_crtab_part_ao_btree_1_prt_p_one_id_idx    
 2     | reindex_crtab_part_ao_btree_1_prt_de_fault_id_idx 
 1     | reindex_crtab_part_ao_btree_id_idx                
(3 rows)
3: COMMIT;
COMMIT
-- After session 3 commits, session 2 could complete, the relfilenode it assigned to the
-- "1_prt_de_fault" index is visible to session 3.
2<:  <... completed>
REINDEX
3: insert into old_relfilenodes (select gp_segment_id as dbid, relfilenode, oid, relname from gp_dist_random('pg_class') where relname like 'reindex_crtab_part_ao_btree%_idx' union all select gp_segment_id as dbid, relfilenode, oid, relname from pg_class where relname like 'reindex_crtab_part_ao_btree%_idx');
INSERT 0 12
-- Expect three distinct relfilenodes per segment for "1_prt_de_fault" index.
3: select distinct count(distinct relfilenode), relname from old_relfilenodes group by dbid, relname;
 count | relname                                           
-------+---------------------------------------------------
 3     | reindex_crtab_part_ao_btree_1_prt_de_fault_id_idx 
 2     | reindex_crtab_part_ao_btree_1_prt_p_one_id_idx    
 1     | reindex_crtab_part_ao_btree_id_idx                
(3 rows)

3: select count(*) from reindex_crtab_part_ao_btree where id = 998;
 count 
-------
 2     
(1 row)
3: set enable_seqscan=false;
SET
3: set enable_indexscan=true;
SET
3: select count(*) from reindex_crtab_part_ao_btree where id = 999;
 count 
-------
 2     
(1 row)
